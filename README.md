# Examples of prompt engineering solutions for kubernetes deployment

|    NAME   |   PROMPT   |   DESCRIPTION[^1]   |   EXAMPLE[^2]   |
|---------- |------------|---------------------|:---------------:|
|  app.yaml |   Create config file for kubernetes deployment in pod for a demo application with image "gcr.io/k8s-k3s/demo:v1.0.0"   |   This configuration defines a Pod named demo-app-pod with one container. The container uses the specified Docker image and exposes port 8080 for the application. You can save this configuration to a file, for example, **demo-app-pod.yaml**, and then deploy it using the **kubectl apply -f demo-app-pod.yaml** command.   |   [example](yaml/app.yaml)   |
|  app-livenessProbe.yaml   |   Create a config file for kubernetes deployment with namespace "demo" in pod with name "app-livenessprob" for an application with name "app" and image "gcr.io/kuar-demo/kuard-amd64:1". Add livenessProbe with default settings.   |   In this configuration:<br>- The Pod is named app-livenessprob and is deployed in the namespace demo.<br>- The container is named app and uses the specified Docker image.<br>- Port 8080 is exposed for the application.<br>- A livenessProbe is defined, checking the health of the application by hitting the /healthz endpoint using the default settings (initialDelaySeconds: 0, periodSeconds: 10).<br>Save this configuration to a file, such as app-livenessprob.yaml, and deploy it using the kubectl apply -f app-livenessprob.yaml command.   |   [example](yaml/app-livenessProbe.yaml)   |
|  app-readinessProbe.yaml | Create a config file for kubernetes deployment with namespace "demo" in pod with name "app-readinessprob" for an application with name "app" and image "gcr.io/k8s-k3s/demo:v2.0.0". Add liveness probe and readiness probe with default settings. |   In this configuration:<br>- The Pod is named app-readinessprob and is deployed in the namespace demo.<br>- The container is named app and uses the specified Docker image (gcr.io/k8s-k3s/demo:v2.0.0).<br>- Port 8080 is exposed for the application.<br>- A liveness probe is defined, checking the health of the application by hitting the /healthz endpoint using the default settings (initialDelaySeconds: 0, periodSeconds: 10).<br>- A readiness probe is defined, checking the readiness of the application by hitting the /readyz endpoint using the default settings (initialDelaySeconds: 0, periodSeconds: 10).<br>Save this configuration to a file, such as app-readinessprob.yaml, and deploy it using the kubectl apply -f app-readinessprob.yaml command.   |   [example](yaml/app-readinessProbe.yaml)   |
|  app-volumeMounts.yaml |  Create config file for kubernetes deployment in pod for a demo application with image "gcr.io/kuar-demo/kuard-amd64:1", livenessProbe and readinessProbe, mount volume in container with path "/data" and mount volume in pod with path: "/var/lib/app"   |   In this configuration:<br>- The Pod is defined with the name demo-app-pod and labeled with app: demo.<br>- The container named demo-app-container uses the specified Docker image.<br>- Port 8080 is exposed for the application.<br>- Both livenessProbe and readinessProbe are defined, checking the health and readiness of the application by hitting the /healthz and /readyz endpoints respectively.<br>- A volume named data-volume is mounted inside the container at path /data using an emptyDir volume type.<br>- Another volume named app-volume is mounted at path /var/lib/app on the host machine.<br>You can save this configuration to a file, for example, demo-app-pod.yaml, and deploy it using the kubectl apply -f demo-app-pod.yaml command.   |   [example](yaml/app-volumeMounts.yaml)   |
|  app-cronjob.yaml | Create a Kubernetes config file for running automated tasks with a CronJob  with name "app-cronjob" for an application with name "hello" and image "bash".  Run command echo "Hello world".  | In this configuration:<br>- The CronJob is named app-cronjob.<br>- It is scheduled to run every 5 minutes ("*/5 * * * *").<br>- The job template defines a Pod template with a single container named hello using the image "bash".<br>- The container runs the command echo 'Hello world'.<br>- The restart policy is set to OnFailure, meaning the Pod will restart if the command fails.<br>Save this configuration to a file, such as app-cronjob.yaml, and deploy it using the kubectl apply -f app-cronjob.yaml command.  |   [example](yaml/app-cronjob.yaml)   |
|  app-job.yaml | Create a Kubernetes config file for run job with name "app-job-rsync" for synchronize container and GC bucket. The container has name "init", image "google/cloud-sdk:275.0.0-alpine", mount volume with name "input-date" and path "/data/input". The GCE persistent disk has pdName "glow-data-disk-200" and file system "ext4". Run gsutil command for replicate the directory structure from a bucket with name "glow-sportradar" to the container disk use -dr flags. | In this configuration:<br>- The Job is named app-job-rsync.<br>- The Pod template defines a single container named init using the image google/cloud-sdk:275.0.0-alpine.<br>- The container runs the gsutil command with the -r flag for recursive synchronization and the -d flag for deleting files in the destination directory that do not exist in the source directory.<br>- The source directory is the GCS bucket named "glow-sportradar", and the destination directory is /data/input in the container.<br>- A volume named input-data is mounted inside the container at path /data/input.<br>- The volume is a GCE persistent disk volume with the specified pdName and fsType.<br>- The restart policy is set to Never, meaning the Pod will not be restarted after completion.<br>Save this configuration to a file, such as app-job-rsync.yaml, and run it using the kubectl apply -f app-job-rsync.yaml command. Make sure you have configured gsutil properly in your container to access the Google Cloud Storage bucket. |   [example](yaml/app-job.yaml)   |
|  app-multicontainer.yaml | Create a Kubernetes config file for "app-multi-containers" deployment two containers in pod. First container has name "1st" and nginx image, also shared mount volume "html" with path "/usr/share/nginx/html". Second container has name "2st"  and debian image, the shared mount volume"html" with path "/html" and runing shell script:<br>while true; do<br>date >> /html/index.html;<br>sleep 1;<br>done | Explanation:<br> -The YAML file defines a Pod named "app-multi-containers".<br> -It defines a volume named "html" of type emptyDir, which provides temporary storage shared between the containers.<br> -The first container named "1st" uses the Nginx image and mounts the "html" volume at "/usr/share/nginx/html".<br> -The second container named "2st" uses the Debian image and mounts the same "html" volume at "/html". It executes a shell script to continuously append the date to a file named "index.html" within the "/html" directory.<br> -The shell script runs an infinite loop that appends the current date to the "index.html" file every second.<br>Save this configuration to a file named "app-multi-containers.yaml" and apply it using the kubectl apply -f app-multi-containers.yaml command. This will create the pod with both containers running and sharing the "html" volume. |   [example](yaml/app-multicontainer.yaml)   |
|  app-resources.yaml | Create a Kubernetes config file for "app-resource" deployment container in pod for an application with name "app" and image "gcr.io/kuar-demo/kuard-amd64:1". Add liveness probe and readiness probe with default settings. Open port 8080 and named it "http". Cluster resources CPU - "100Mi" and memory "128Mi" (limit "256Mi"). | Explanation:<br> -The configuration defines a pod named "app-resource" with a single container.<br> -The container is named "app-container" and uses the image "gcr.io/kuar-demo/kuard-amd64:1".<br> -Port 8080 is opened and named "http".<br> -Resource requests and limits are specified for CPU and memory.<br> -Liveness and readiness probes are added to the container, targeting the "/healthz" path on port 8080.<br>Save this configuration to a file, such as "app-resource.yaml", and apply it using the kubectl apply -f app-resource.yaml command. This will create the pod with the specified resource settings and probes. |   [example](yaml/app-resources.yaml)   |
|  app-secret-env.yaml | Create a Kubernetes config file for "app-secret-env" deployment container in pod for an application with name "mycontainer" and redis image. Set two secret environment variables: SECRET_USERNAME and SECRET_PASSWORD.  | Explanation:<br> -The configuration defines a pod named "app-secret-env" with a single container.<br> -The container is named "mycontainer" and uses the image "redis".<br> -Two secret environment variables, SECRET_USERNAME and SECRET_PASSWORD, are set for the container.<br> -The values for these environment variables are sourced from a Kubernetes Secret named "mysecrets", with keys "username" and "password" respectively.<br> -Before applying this configuration, you need to create a Kubernetes Secret named "mysecrets" with the keys "username" and "password" containing the appropriate values.<br>Save this configuration to a file, such as "app-secret-env.yaml", and apply it using the kubectl apply -f app-secret-env.yaml command. This will create the pod with the specified secret environment variables. |   [example](yaml/app-secret-env.yaml)   |


[^1]: Description and explanation by OpenAI
[^2]: Files are generated OpenAI